<!DOCTYPE html>
<html>
	<head>
		<title>Proof of Concept Pei Pei</title>
        <link rel="stylesheet" href="bunny.css">
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@200&display=swap" rel="stylesheet">
	</head>
	<body>
		<a href ="index.html">
			<img src="img/namered.png" alt="Virtual House" style="width:20%;">
		  </a>
		<div id = "three">
		<script src="threejs/build/three.js"></script>
        <script src="threejs/examples/js/loaders/GLTFLoader.js"></script>
        <script type="module">
        import { DeviceOrientationControls } from '/threejs/examples/jsm/controls/DeviceOrientationControls.js';
	

		var container, controls;
		var camera, scene, renderer, light, mixer;
		var clock = new THREE.Clock();
		var mesh;
        var effect;
        var group = [];

        let mouseX = 0;
        let mouseY = 0;
        const mouse = new THREE.Vector2();

        const raycaster = new THREE.Raycaster();

		init();
		animate();
		 var granted = false;
		function init() {
            

			//basics
			container = document.createElement('three');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 200);
			// camera.position.set(100,100, 10);
			controls = new DeviceOrientationControls( camera, true );

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0x000000);

			let orangeLight = new THREE.PointLight(0x175575,10,10);
			orangeLight.position.set(20,30,2);
			scene.add(orangeLight);

			let blueLight = new THREE.PointLight(0x175575,4,0);
			blueLight.position.set(-10,30,12);
			scene.add(blueLight);
            const light = new THREE.HemisphereLight( 0xeb34cf, 0xeb34cf, 1 );
            scene.add( light );

            var cubemap = new THREE.CubeTextureLoader()
			.setPath( 'img/' )
			.load( [
				'pei.png',
				'pei.png',
				'pei.png',
				'pei.png',
				'pei.png',
				'pei.png'
			] );

            var wallMaterial = new THREE.MeshStandardMaterial( { //material to for disco ball
              	bumpScale: 0.01,
                metalness: 1,
				roughness: 0.1,
				color: 0x333333,
				envMap: cubemap,
			} );
            wallMaterial.side = THREE.DoubleSide;

			//material
			var normalMaterial = new THREE.MeshStandardMaterial( { //material to for disco ball
				metalness: 0.7,
				roughness: 0.2,
				color: 0x555555,
				//bumpMap: new THREE.TextureLoader().load("img/threedisco.png"),

			} );
			
			// model
			var loader = new THREE.GLTFLoader();
			loader.load("models/city.gltf", function (gltf) {
                let home = gltf.scene.getObjectByName("Plane");
				console.log(home);
				home.material = wallMaterial;
                gltf.scene.traverse(function (child) {
					if (child.isMesh) {
						group.push(child);
					}

				});
                //group.push(gltf.scene.getObjectByName("arrow"));
                // group.add(gltf.scene.getObjectByName("arrow2"));
                // group.add(gltf.scene.getObjectByName("arrow.001"));

                
				scene.add(gltf.scene);


			});

			// renderer and controls
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth *0.8, window.innerHeight*0.8);
			container.appendChild(renderer.domElement);

			// controls = new OrbitControls( camera, renderer.domElement );
			// controls.minDistance = 3;
			// controls.maxDistance = 5;

            // effect = new ParallaxBarrierEffect( renderer );
			// effect.setSize( window.innerWidth *0.8, window.innerHeight*0.8 );


		}
		
		console.log(scene.getObjectByName( "Group" ));
		function animate() {
			requestAnimationFrame(animate);

			// const timer = 0.0001 * Date.now();

            // camera.position.x += ( mouse.x - camera.position.x ) * .05;
            // camera.position.y += ( - mouse.y - camera.position.y ) * .05;

            // camera.lookAt( scene.position );

            // update the picking ray with the camera and mouse position
            raycaster.setFromCamera( mouse, camera );
            // calculate objects intersecting the picking ray
				controls.update();
			

            renderer.render( scene, camera );
            
		}
		alert("new version 2")
		console.log(controls);
		window.addEventListener( 'resize', onWindowResize, false );
		function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth*0.8, window.innerHeight *0.8);
		}
        var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

        // window.addEventListener( 'mousemove', onDocumentMouseMove, false );
        // function onDocumentMouseMove( event ) {

        //     mouse.x = ( event.clientX - windowHalfX ) / 100;
        //     mouse.y = ( event.clientY - windowHalfY ) / 100;

        // }

        window.addEventListener('mousedown', onMouseDown, false);
        function onMouseDown(event){
            const intersects = raycaster.intersectObjects( group, true );
            for ( let i = 0; i < intersects.length; i ++ ) {
                console.log(intersects[i]);
                if (intersects[i].object.name == "arrow" || intersects[i].object.name == "arrow2" || intersects[i].object.name == "arrow1"){
                    alert("arrow clicked");
                }
            }
        }

        // window.addEventListener('touchmove', onTouchMove, false);
        // function onTouchMove(event){

        //     mouse.x = ( event.touches[ 0 ].clientX / window.innerWidth ) * 4 - 1;
        //     mouse.y = - ( event.touches[ 0 ].clientY / window.innerHeight ) * 4 + 1;

            
        // }

        window.addEventListener('touchstar', onTouchStart, false);
        function onTouchStart(event){
            const intersects = raycaster.intersectObjects( group, true );
            for ( let i = 0; i < intersects.length; i ++ ) {
                console.log(intersects[i]);
                if (intersects[i].object.name == "arrow" || intersects[i].object.name == "arrow2" || intersects[i].object.name == "arrow1"){
                    alert("arrow clicked");
                }
            }
        }
		</script>
		</div>
	</body>
</html>