<!DOCTYPE html>
<html>
	<head>
		<title>Proof of Concept Pei Pei</title>
		<link rel="stylesheet" href="testscene.css">
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@200&display=swap" rel="stylesheet">
	</head>
	<body>
		<div id="overlay">
			<button id="startButton" class= "button">Enable Controls</button>
		</div>
		
		<div id = "three">
		<script src="threejs/build/three.js"></script>
        <script src="threejs/examples/js/loaders/GLTFLoader.js"></script>
        <script type="module">
			import { DeviceOrientationControls } from '/threejs/examples/jsm/controls/DeviceOrientationControls.js';
			import { GUI } from '/three/dat.gui.module.js';
			import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.5.0/dist/tween.esm.js';
			import { OrbitControls } from '/threejs/examples/jsm/controls/OrbitControls.js';

			var container, controls, positions, cube;
			var camera, scene, renderer, light, kaiju;
			var mesh;
			var group = [];

			let mouseX = 0;
			let mouseY = 0;
			const mouse = new THREE.Vector2();

			const raycaster = new THREE.Raycaster();

			init();
			animate();
			function init() {
				//basics
				container = document.createElement('three');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 200);
				camera.position.set(0,4,12);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x000022);

				let orangeLight = new THREE.PointLight(0x175575,10,10);
				orangeLight.position.set(20,30,2);
				scene.add(orangeLight);

				let blueLight = new THREE.PointLight(0x175575,4,0);
				blueLight.position.set(-10,10,12);
				scene.add(blueLight);

				const light = new THREE.HemisphereLight( 0xeb34cf, 0xeb34cf, 1 );
				scene.add( light );

				var cubemap = new THREE.CubeTextureLoader()
				.setPath( 'img/' )
				.load( [
				'px.png',
				'nx.png',
				'py.png',
				'ny.png',
				'pz.png',
				'nz.png'
				] );
				scene.background= cubemap;

				var wallMaterial = new THREE.MeshStandardMaterial( { //material to for disco ball
					metalness: 0.1,
					roughness: 0.5,
					color: 0x222222,
					envMap: cubemap,
				} );
				wallMaterial.side = THREE.DoubleSide;

				const geometry = new THREE.BoxGeometry( 0.5, 0.5, 0.5 );
				const material = new THREE.MeshBasicMaterial( {color: 0x000000} );
				cube = new THREE.Mesh( geometry, material );
				cube.material.transparent = true ;
				scene.add( cube );
				cube.position.set(0,0,-4);
				cube.add(camera);

				const cube2 = new THREE.Mesh( geometry, material );
				cube2.material.transparent = true ;
				scene.add( cube2 );
				cube2.position.set(0,0,0);
				cube2.add(cube);

				controls = new DeviceOrientationControls( cube, true );
				controls.disconnect();
				controls.enabled = false;
				console.log(controls);

				// GUI
				var params = {
					fov: 45,
					Y: 0,
					Z: 0,
				};

				var gui = new GUI({
					width : 300
				}); 

				function updateCamera() {
					camera.updateProjectionMatrix();
				}
				var folder = gui.addFolder('Camera Controls');

				folder.add(camera, 'fov', 1, 180).onChange(updateCamera);
				folder.add(params, 'Y', 0, 5).step(0.01).onChange(function (value) { cube.position.y = value });
				folder.add(params, 'Z', 0, 10).step(0.01).onChange(function (value) { cube.position.z = value });
				folder.open();
				
				//TWEEN Positions
				positions = [];
				positions.push(new THREE.Vector3(-5, 0, 0));
				positions.push(new THREE.Vector3(0, 5, 15));
				positions.push(new THREE.Vector3(15, 10, 0));
				positions.push(new THREE.Vector3(0, 15, 15));
				positions.push(new THREE.Vector3(-15, 35, 0));

				// model
				var loader = new THREE.GLTFLoader();
				loader.load("models/city2.gltf", function (gltf) {
					gltf.scene.getObjectByName("Plane").material = wallMaterial;
					kaiju = gltf.scene.getObjectByName("Plane").material = wallMaterial;

					scene.add(gltf.scene);


				});

				// renderer and controls
				renderer = new THREE.WebGLRenderer({ antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				// controls = new OrbitControls( camera, renderer.domElement );
				// controls.minDistance = 3;
				// controls.maxDistance = 5;
				alert("This experiment is only built for phones")
			}
			
			/**
			 * BUTTONS
			**/  

			const startButton = document.getElementById( 'startButton' );
				startButton.addEventListener( 'click', function () {
					controls.connect();
					controls.enabled = true;
					console.log(controls);
			} );
			
			var tapButton = document.getElementById ("powerbutton");
			document.getElementById ("powerbutton").addEventListener ("touchstart", interactStart, false);
			document.getElementById ("powerbutton").addEventListener ("touchend", interactEnd, false);

			var clicks = 0;
			var counter = 0;
			function interactStart() {
				//button style
				tapButton.style.boxShadow = "0px 0px 50px #777777";
    			tapButton.style.background = "rgb(126, 214, 218)";

				//controls
				console.log("clicl");
				clicks++;
				document.getElementById("clicks").innerHTML = clicks;
				if (clicks > 3){
					controls.disconnect();
					controls.enabled = false;
					console.log(positions[counter]);
					var tween = new TWEEN.Tween(cube.position).to(positions[counter], 1000).start();
					// var tween = new TWEEN.Tween(cube.position).to( { y:5 }, 2000 ).start();
					controls.connect();
					controls.enabled = true;
					clicks = 0;
					console.log(camera.position);
					if (counter == positions.length - 1){
						counter = 0;
					}
					else{
						counter ++;
					}
				}
			};
			
			function interactEnd(){
				//button style
				tapButton.style.boxShadow = "none";
    			tapButton.style.background = "rgb(30, 190, 199)";

				
			}

			function animate() {
				requestAnimationFrame(animate);
				TWEEN.update();
				controls.update();
				renderer.render( scene, camera );
				
			}
			
			window.addEventListener( 'resize', onWindowResize, false );
			function onWindowResize(){
					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();
					renderer.setSize( window.innerWidth , window.innerHeight);
			}
			
			
		</script>
		</div>
		<button type="button" class= "button tapcounter" id="powerbutton">
			Tap to power up 
			<p>
				<a id="clicks">0</a>
			</p>
		</button>
	</body>
</html>