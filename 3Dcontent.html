<!DOCTYPE html>
<html>

<head>
    <title>Prototype Test</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Encode+Sans+SC&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="testscene.css">
</head>

<body>
    <div id="three">
        <script src="threejs/build/three.js"></script>
        <script src="threejs/examples/js/loaders/GLTFLoader.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.0.5/gsap.min.js"></script>
        <script type="module">
            import { GUI } from '/three/dat.gui.module.js';
            import TWEEN from 'https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.5.0/dist/tween.esm.js';
            import { OrbitControls } from '/threejs/examples/jsm/controls/OrbitControls.js';
            import { EffectComposer } from '/threejs/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from '/threejs/examples/jsm/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/threejs/examples/jsm/postprocessing/UnrealBloomPass.js';

            var container, controls, positions, cube, movingCube, composer;
            var camera, scene, renderer, light;
            var mesh;
            var group = [];

            const raycaster = new THREE.Raycaster();

            init();
            animate();
            function init() {
                //basics
                container = document.createElement('three');
                document.body.appendChild(container);

                camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.25, 200);
                camera.position.set(3, 0, 0);
                camera.rotation.y += Math.PI/2;
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x000000);

                const light = new THREE.HemisphereLight(0xffffff, 0xffffff, 1);
                scene.add(light);


                // model
                var loader = new THREE.GLTFLoader();
                loader.load("models/box.gltf", function (gltf) {
                    mesh = gltf.scene;
                    scene.add(gltf.scene);
                });

                // renderer and controls
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(renderer.domElement);

                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);

                //const filmPass = new FilmPass(0.4, 0.3, 600, false);
                //composer.addPass( filmPass );

                // const unrealBloomPass = new UnrealBloomPass();
                // composer.addPass( unrealBloomPass );

                // controls = new OrbitControls(camera, renderer.domElement);
                // controls.minDistance = 3;
                // controls.maxDistance = 5;
            }
            function animate() {
                requestAnimationFrame(animate);
                // controls.update();
                composer.render(); //render and post
                // renderer.render( scene, camera );

            }

            var mouse = new THREE.Vector2(0, 0);
            window.addEventListener('mousemove', onMouseMove);
            function onMouseMove(event) {
                gsap.to(mouse, 0.5, {
                    x: (event.clientX / window.innerWidth) * 2 - 1,
                    y: -(event.clientY / window.innerHeight) * 2 + 1
                })

                gsap.to(mesh.rotation, 0.5, {
                z: mouse.y * 0.3,
            y: mouse.x * (Math.PI / 6)
        })
            }

            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

        </script>
    </div>

</body>

</html>