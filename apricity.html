<!DOCTYPE html>
<html>

<head>
    <title>Proof of Concept Pei Pei</title>
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300&display=swap" rel="stylesheet">
</head>
<style>
    body {
        margin: 0px;
        font-family: 'Source Code Pro', monospace;
        background-color: rgb(134, 251, 255);
    }
</style>

<body>
    <p><br />
        :::'###::::'########::'########::'####::'######::'####:'########:'##:::'##:<br />
        ::'## ##::: ##.... ##: ##.... ##:. ##::'##... ##:. ##::... ##..::. ##:'##::<br />
        :'##:. ##:: ##:::: ##: ##:::: ##:: ##:: ##:::..::: ##::::: ##:::::. ####:::<br />
        '##:::.##: ########:: ########::: ##:: ##:::::::: ##::::: ##::::::. ##::::<br />
        #########: ##.....::: ##.. ##:::: ##:: ##:::::::: ##::::: ##::::::: ##::::<br />
        ##.... ##: ##:::::::: ##::. ##::: ##:: ##::: ##:: ##::::: ##::::::: ##::::<br />
        ##:::: ##: ##:::::::: ##:::. ##:'####:. ######::'####:::: ##::::::: ##::::<br />
        ..:::::..::..:::::::::..:::::..::....:::......:::....:::::..::::::::..:::::<br />
    </p>
    <div id="three">
        <script src="threejs/build/three.js"></script>
        <script src="threejs/examples/js/loaders/GLTFLoader.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.0.5/gsap.min.js"></script>
        <script type="module">
            import { OrbitControls } from '/threejs/examples/jsm/controls/OrbitControls.js';
            import { EffectComposer } from '/threejs/examples/jsm/postprocessing/EffectComposer.js';
            import { RenderPass } from '/threejs/examples/jsm/postprocessing/RenderPass.js';
            import { UnrealBloomPass } from '/threejs/examples/jsm/postprocessing/UnrealBloomPass.js';
            import { FilmPass } from '/threejs/examples/jsm/postprocessing/FilmPass.js';

            var container, controls, composer;
            var camera, scene, renderer;
            var mesh, geometry, shadermaterial, plane; //the house
            var id = 0; //to check if we are animating
            init();
            animate();
            function init() {

                //basics

                camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.25, 200);
                camera.position.set(0, 0, 9);

                scene = new THREE.Scene();
                const material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });

                // model
                var loader = new THREE.GLTFLoader();
                loader.load("img/guiville/assets.gltf", function (gltf) {
                    mesh = gltf.scene.getObjectByName("house");
                    mesh.material = material;
                    scene.add(mesh);
                });


                geometry = new THREE.PlaneGeometry(30, 20, 40, 40); //
                shadermaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        utime: { value: 0.0 },
                        width: { value: 30.0 },
                        height: { value: 20.0 },
                        uTexture: { value: new THREE.TextureLoader().load("img/mecube.png") },
                    },
                    vertexShader: vertexShader(),
                    fragmentShader: clearShader(),
                });
                shadermaterial.transparent = true;


                plane = new THREE.Mesh(geometry, shadermaterial);
                scene.add(plane);
                plane.position.set(-0, -0, 0.08);
                function vertexShader() {
                    return `
                    uniform float utime;
                    uniform float width;
                    uniform float height;

                    varying vec2 vUv; //x and y unit vector
                    varying float zpos; //this will be z position after transformation

                    void main(){
                    vUv = uv;   //for use in frag

                    float dx = 2. - uv.x + width;   
                    float dy = 8. -uv.y + height;
                    float freq = sqrt(dx*dx + dy*dy);
                    float amp = 0.2;
                    float angle = -utime*3.0+freq*8.0;
                        
                    zpos = sin(angle)*amp;

                    vec3 local3 = vec3(uv.x*width, uv.y*height, zpos);
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);
                    }
                    `
                }
                function clearShader() {
                    return `
                    uniform float utime;
                    uniform sampler2D uTexture;
                    varying vec2 vUv;
                    varying float zpos;
                
                    void main() {
                        vec3 texture = texture2D(uTexture, vUv + zpos).rgb;
                        float shadow = clamp(zpos / 1., 0., 1.);
                        gl_FragColor = vec4(texture + shadow, 0.1);
                        gl_FragColor.a = 0.2;
                    }
                `
                }


                // renderer and controls
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setClearColor(0x000000, 0); // the default
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('three').appendChild(renderer.domElement);

                composer = new EffectComposer(renderer);
                const renderPass = new RenderPass(scene, camera);
                composer.addPass(renderPass);

                // controls = new OrbitControls( camera, renderer.domElement );
                // controls.minDistance = 11;
                // controls.maxDistance = 11;

                var mouse = new THREE.Vector2(0, 0);
                window.addEventListener('mousemove', onMouseMove);
                function onMouseMove(event) {
                    gsap.to(mouse, 0.5, {
                        x: (event.clientX / window.innerWidth) * 2 - 1,
                        y: -(event.clientY / window.innerHeight) * 2 + 1
                    })
                    gsap.to(mesh.rotation, 0.5, {
                        z: mouse.y * 0.3,
                        y: mouse.x * (Math.PI / 6)
                    })
                }
            }

            /**
             * BUTTONS
            **/


            function animate() {
                id = requestAnimationFrame(animate);
                // controls.update();
                composer.render(); //render and post
                // renderer.render( scene, camera );
                console.log("rendering")

            }



            window.addEventListener('resize', onWindowResize, false);
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

        </script>

    </div>
</body>

</html>